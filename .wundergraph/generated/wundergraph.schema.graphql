# Code generated by "wunderctl"; DO NOT EDIT.

"""
The @removeNullVariables directive allows you to remove variables with null value from your GraphQL Query or Mutation Operations.

A potential use-case could be that you have a graphql upstream which is not accepting null values for variables.
By enabling this directive all variables with null values will be removed from upstream query.

query ($say: String, $name: String) @removeNullVariables {
	hello(say: $say, name: $name)
}

Directive will transform variables json and remove top level null values.
{ "say": null, "name": "world" }

So upstream will receive the following variables:

{ "name": "world" }
"""
directive @removeNullVariables on QUERY | MUTATION

directive @hooksVariable on VARIABLE_DEFINITION

directive @jsonSchema(
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  title: String
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  description: String
  """
  The value of "multipleOf" MUST be a number, strictly greater than 0.
  
  A numeric instance is valid only if division by this keyword's value
  results in an integer.
  """
  multipleOf: Int
  """
  The value of "maximum" MUST be a number, representing an inclusive
  upper limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is less than or exactly equal to "maximum".
  """
  maximum: Int
  """
  The value of "exclusiveMaximum" MUST be number, representing an
  exclusive upper limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly less than (not equal to) "exclusiveMaximum".
  """
  exclusiveMaximum: Int
  """
  The value of "minimum" MUST be a number, representing an inclusive
  lower limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is greater than or exactly equal to "minimum".
  """
  minimum: Int
  """
  The value of "exclusiveMinimum" MUST be number, representing an
  exclusive lower limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly greater than (not equal to) "exclusiveMinimum".
  """
  exclusiveMinimum: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is less
  than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  """
  maxLength: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is
  greater than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minLength: Int
  """
  The value of this keyword MUST be a string.  This string SHOULD be a
  valid regular expression, according to the ECMA 262 regular
  expression dialect.
  
  A string instance is considered valid if the regular expression
  matches the instance successfully.  Recall: regular expressions are
  not implicitly anchored.
  """
  pattern: String
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "maxItems" if its size is less
  than, or equal to, the value of this keyword.
  """
  maxItems: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "minItems" if its size is greater
  than, or equal to, the value of this keyword.
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minItems: Int
  """
  The value of this keyword MUST be a boolean.
  
  If this keyword has boolean value false, the instance validates
  successfully.  If it has boolean value true, the instance validates
  successfully if all of its elements are unique.
  
  Omitting this keyword has the same behavior as a value of false.
  """
  uniqueItems: Boolean
  commonPattern: COMMON_REGEX_PATTERN
  """Optional field to apply the JSON schema to"""
  on: String
) repeatable on VARIABLE_DEFINITION

directive @rbac(
  """the user must match all roles"""
  requireMatchAll: [WG_ROLE]
  """the user must match at least one of the roles"""
  requireMatchAny: [WG_ROLE]
  """the user must not match all of the roles"""
  denyMatchAll: [WG_ROLE]
  """the user must not match any of the roles"""
  denyMatchAny: [WG_ROLE]
) on QUERY | MUTATION | SUBSCRIPTION

"""
The @fromClaim directive sets the variable to the value retrieved from the given a claim.
Adding this directive makes the operation require authentication.
"""
directive @fromClaim(name: WG_CLAIM, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The directive @injectCurrentDateTime injects a DateTime string of the current date and time into the variable.
This variable MUST be a string compatible scalar. 

The default format, is: ISO 8601
If no format is chosen, the default format is used.
Custom formats are allowed by specifying a format conforming to the Golang specification for specifying a date time format.
"""
directive @injectCurrentDateTime(
  format: WunderGraphDateTimeFormat = ISO8601
  """
  customFormat must conform to the Golang specification for specifying a date time format
  """
  customFormat: String
  on: String = ""
) repeatable on VARIABLE_DEFINITION

"""
The directive @injectGeneratedUUID injects a generated UUID into the variable.
This variable MUST be a string.
At the same time, it removes the variable from the input definition,
disallowing the user to supply it.

This means, the UUID is 100% generated server-side and can be considered untempered.
"""
directive @injectGeneratedUUID(on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @internalOperation Directive marks an Operation as internal.
By doing so, the Operation is no longer accessible from the public API.
It can only be accessed by internal services, like hooks.
"""
directive @internalOperation on QUERY | MUTATION | SUBSCRIPTION

"""
The directive @injectEnvironmentVariable allows you to inject an environment variable into the variable definition.
"""
directive @injectEnvironmentVariable(name: String!, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @export directive instructs the Execution Planner to export the field during the execution into the variable of the 'as' argument.
As the execution is depth first, a field can only be used after it has been exported.
Additionally, a field can only be used after using the '_join' field or on a different data source.
It's not possible to export a field and use it in for the same data source.

Note that the @export directive only works on fields that return a single value.
It's not possible to export a list or object field.
"""
directive @export(
  """The argument 'as' is the name of the variable to export the field to."""
  as: String!
) on FIELD

"""
The directive @internal marks a variable definition as internal so that clients can't access it.
The field is also not visible in the public API.
It's only being used as an internal variable to export fields into.
"""
directive @internal on VARIABLE_DEFINITION

"""
The @transform directive allows to apply transformations to the response.
By applying the directive, the shape of the response can be altered,
which will also modify the JSON-Schema of the response.
That is, you will keep full type safety and code-generation for transformed fields.
"""
directive @transform(
  """
  Using the 'get' transformation allows you to extract a nested field using a JSON path.
  This is useful to unnest data, e.g. when using the '_join' field, which adds an extra layer of nesting.
  
  Example:
  
  query GetName {
      name: me @transform(get: "info.name") {
          info {
              name
          }
      }
  }
  
  Before the transformation, the resolve looks like this:
  
  {
      "name": {
          "info": {
              "name": "John Doe"
          }
      }
  }
  
  With the transformation applied, the response will be reshaped like this:
  
  {
      "name": "John Doe"
  }
  """
  get: String
) on FIELD

enum db_QueryMode {
  default
  insensitive
}

input db_NestedStringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringFilter
}

input db_StringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: db_QueryMode
  not: db_NestedStringFilter
}

input db_NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_DateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_NestedDateTimeNullableFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableFilter
}

input db_DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableFilter
}

input db_NestedIntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntFilter
}

input db_IntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntFilter
}

input db_NestedStringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringNullableFilter
}

input db_StringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: db_QueryMode
  not: db_NestedStringNullableFilter
}

input db_SectionsListRelationFilter {
  every: db_sectionsWhereInput
  some: db_sectionsWhereInput
  none: db_sectionsWhereInput
}

input db_scriptsWhereInput {
  AND: db_scriptsWhereInput
  OR: [db_scriptsWhereInput]
  NOT: db_scriptsWhereInput
  id: db_StringFilter
  created_at: db_DateTimeFilter
  updated_at: db_DateTimeNullableFilter
  name: db_StringFilter
  summary: db_StringFilter
  audio_url: db_StringNullableFilter
  sections: db_SectionsListRelationFilter
}

input db_ScriptsRelationFilter {
  is: db_scriptsWhereInput
  isNot: db_scriptsWhereInput
}

input db_FragmentsListRelationFilter {
  every: db_fragmentsWhereInput
  some: db_fragmentsWhereInput
  none: db_fragmentsWhereInput
}

input db_sectionsWhereInput {
  AND: db_sectionsWhereInput
  OR: [db_sectionsWhereInput]
  NOT: db_sectionsWhereInput
  id: db_StringFilter
  created_at: db_DateTimeFilter
  updated_at: db_DateTimeNullableFilter
  sort_order: db_IntFilter
  name: db_StringFilter
  summary: db_StringFilter
  audio_url: db_StringNullableFilter
  script_id: db_StringFilter
  scripts: db_ScriptsRelationFilter
  fragments: db_FragmentsListRelationFilter
}

input db_SectionsRelationFilter {
  is: db_sectionsWhereInput
  isNot: db_sectionsWhereInput
}

input db_fragmentsWhereInput {
  AND: db_fragmentsWhereInput
  OR: [db_fragmentsWhereInput]
  NOT: db_fragmentsWhereInput
  id: db_StringFilter
  created_at: db_DateTimeFilter
  updated_at: db_DateTimeNullableFilter
  sort_order: db_IntFilter
  content: db_StringFilter
  audio_url: db_StringFilter
  section_id: db_StringFilter
  sections: db_SectionsRelationFilter
}

enum db_SortOrder {
  asc
  desc
}

input db_sectionsOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_scriptsOrderByWithRelationInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
  sections: db_sectionsOrderByRelationAggregateInput
}

input db_fragmentsOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_sectionsOrderByWithRelationInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
  script_id: db_SortOrder
  scripts: db_scriptsOrderByWithRelationInput
  fragments: db_fragmentsOrderByRelationAggregateInput
}

input db_fragmentsOrderByWithRelationInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  content: db_SortOrder
  audio_url: db_SortOrder
  section_id: db_SortOrder
  sections: db_sectionsOrderByWithRelationInput
}

input db_fragmentsWhereUniqueInput {
  id: String
}

enum db_FragmentsScalarFieldEnum {
  id
  created_at
  updated_at
  sort_order
  content
  audio_url
  section_id
}

input db_sectionsWhereUniqueInput {
  id: String
}

enum db_SectionsScalarFieldEnum {
  id
  created_at
  updated_at
  sort_order
  name
  summary
  audio_url
  script_id
}

type db_ScriptsCountOutputType {
  sections: Int!
  _join: Query!
}

type db_scripts {
  id: String!
  created_at: DateTime!
  updated_at: DateTime
  name: String!
  summary: String!
  audio_url: String
  sections(where: db_sectionsWhereInput, orderBy: [db_sectionsOrderByWithRelationInput], cursor: db_sectionsWhereUniqueInput, take: Int, skip: Int, distinct: [db_SectionsScalarFieldEnum]): [db_sections]
  _count: db_ScriptsCountOutputType!
  _join: Query!
}

type db_SectionsCountOutputType {
  fragments: Int!
  _join: Query!
}

type db_sections {
  id: String!
  created_at: DateTime!
  updated_at: DateTime
  sort_order: Int!
  name: String!
  summary: String!
  audio_url: String
  script_id: String!
  scripts: db_scripts!
  fragments(where: db_fragmentsWhereInput, orderBy: [db_fragmentsOrderByWithRelationInput], cursor: db_fragmentsWhereUniqueInput, take: Int, skip: Int, distinct: [db_FragmentsScalarFieldEnum]): [db_fragments]
  _count: db_SectionsCountOutputType!
  _join: Query!
}

type db_fragments {
  id: String!
  created_at: DateTime!
  updated_at: DateTime
  sort_order: Int!
  content: String!
  audio_url: String!
  section_id: String!
  sections: db_sections!
  _join: Query!
}

type db_FragmentsCountAggregateOutputType {
  id: Int!
  created_at: Int!
  updated_at: Int!
  sort_order: Int!
  content: Int!
  audio_url: Int!
  section_id: Int!
  _all: Int!
  _join: Query!
}

type db_FragmentsAvgAggregateOutputType {
  sort_order: Float
  _join: Query!
}

type db_FragmentsSumAggregateOutputType {
  sort_order: Int
  _join: Query!
}

type db_FragmentsMinAggregateOutputType {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int
  content: String
  audio_url: String
  section_id: String
  _join: Query!
}

type db_FragmentsMaxAggregateOutputType {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int
  content: String
  audio_url: String
  section_id: String
  _join: Query!
}

type db_AggregateFragments {
  _count: db_FragmentsCountAggregateOutputType
  _avg: db_FragmentsAvgAggregateOutputType
  _sum: db_FragmentsSumAggregateOutputType
  _min: db_FragmentsMinAggregateOutputType
  _max: db_FragmentsMaxAggregateOutputType
  _join: Query!
}

input db_fragmentsCountOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  content: db_SortOrder
  audio_url: db_SortOrder
  section_id: db_SortOrder
}

input db_fragmentsAvgOrderByAggregateInput {
  sort_order: db_SortOrder
}

input db_fragmentsMaxOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  content: db_SortOrder
  audio_url: db_SortOrder
  section_id: db_SortOrder
}

input db_fragmentsMinOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  content: db_SortOrder
  audio_url: db_SortOrder
  section_id: db_SortOrder
}

input db_fragmentsSumOrderByAggregateInput {
  sort_order: db_SortOrder
}

input db_fragmentsOrderByWithAggregationInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  content: db_SortOrder
  audio_url: db_SortOrder
  section_id: db_SortOrder
  _count: db_fragmentsCountOrderByAggregateInput
  _avg: db_fragmentsAvgOrderByAggregateInput
  _max: db_fragmentsMaxOrderByAggregateInput
  _min: db_fragmentsMinOrderByAggregateInput
  _sum: db_fragmentsSumOrderByAggregateInput
}

input db_NestedStringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_StringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: db_QueryMode
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_NestedIntNullableFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntNullableFilter
}

input db_NestedDateTimeNullableWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedDateTimeNullableFilter
  _max: db_NestedDateTimeNullableFilter
}

input db_DateTimeNullableWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedDateTimeNullableFilter
  _max: db_NestedDateTimeNullableFilter
}

input db_NestedFloatFilter {
  equals: Float
  in: [Float]
  notIn: [Float]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: db_NestedFloatFilter
}

input db_NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntWithAggregatesFilter
  _count: db_NestedIntFilter
  _avg: db_NestedFloatFilter
  _sum: db_NestedIntFilter
  _min: db_NestedIntFilter
  _max: db_NestedIntFilter
}

input db_IntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntWithAggregatesFilter
  _count: db_NestedIntFilter
  _avg: db_NestedFloatFilter
  _sum: db_NestedIntFilter
  _min: db_NestedIntFilter
  _max: db_NestedIntFilter
}

input db_fragmentsScalarWhereWithAggregatesInput {
  AND: db_fragmentsScalarWhereWithAggregatesInput
  OR: [db_fragmentsScalarWhereWithAggregatesInput]
  NOT: db_fragmentsScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  created_at: db_DateTimeWithAggregatesFilter
  updated_at: db_DateTimeNullableWithAggregatesFilter
  sort_order: db_IntWithAggregatesFilter
  content: db_StringWithAggregatesFilter
  audio_url: db_StringWithAggregatesFilter
  section_id: db_StringWithAggregatesFilter
}

type db_FragmentsGroupByOutputType {
  id: String!
  created_at: DateTime!
  updated_at: DateTime
  sort_order: Int!
  content: String!
  audio_url: String!
  section_id: String!
  _count: db_FragmentsCountAggregateOutputType
  _avg: db_FragmentsAvgAggregateOutputType
  _sum: db_FragmentsSumAggregateOutputType
  _min: db_FragmentsMinAggregateOutputType
  _max: db_FragmentsMaxAggregateOutputType
  _join: Query!
}

input db_scriptsWhereUniqueInput {
  id: String
}

enum db_ScriptsScalarFieldEnum {
  id
  created_at
  updated_at
  name
  summary
  audio_url
}

type db_ScriptsCountAggregateOutputType {
  id: Int!
  created_at: Int!
  updated_at: Int!
  name: Int!
  summary: Int!
  audio_url: Int!
  _all: Int!
  _join: Query!
}

type db_ScriptsMinAggregateOutputType {
  id: String
  created_at: DateTime
  updated_at: DateTime
  name: String
  summary: String
  audio_url: String
  _join: Query!
}

type db_ScriptsMaxAggregateOutputType {
  id: String
  created_at: DateTime
  updated_at: DateTime
  name: String
  summary: String
  audio_url: String
  _join: Query!
}

type db_AggregateScripts {
  _count: db_ScriptsCountAggregateOutputType
  _min: db_ScriptsMinAggregateOutputType
  _max: db_ScriptsMaxAggregateOutputType
  _join: Query!
}

input db_scriptsCountOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
}

input db_scriptsMaxOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
}

input db_scriptsMinOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
}

input db_scriptsOrderByWithAggregationInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
  _count: db_scriptsCountOrderByAggregateInput
  _max: db_scriptsMaxOrderByAggregateInput
  _min: db_scriptsMinOrderByAggregateInput
}

input db_NestedStringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedStringNullableFilter
  _max: db_NestedStringNullableFilter
}

input db_StringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: db_QueryMode
  not: db_NestedStringNullableWithAggregatesFilter
  _count: db_NestedIntNullableFilter
  _min: db_NestedStringNullableFilter
  _max: db_NestedStringNullableFilter
}

input db_scriptsScalarWhereWithAggregatesInput {
  AND: db_scriptsScalarWhereWithAggregatesInput
  OR: [db_scriptsScalarWhereWithAggregatesInput]
  NOT: db_scriptsScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  created_at: db_DateTimeWithAggregatesFilter
  updated_at: db_DateTimeNullableWithAggregatesFilter
  name: db_StringWithAggregatesFilter
  summary: db_StringWithAggregatesFilter
  audio_url: db_StringNullableWithAggregatesFilter
}

type db_ScriptsGroupByOutputType {
  id: String!
  created_at: DateTime!
  updated_at: DateTime
  name: String!
  summary: String!
  audio_url: String
  _count: db_ScriptsCountAggregateOutputType
  _min: db_ScriptsMinAggregateOutputType
  _max: db_ScriptsMaxAggregateOutputType
  _join: Query!
}

type db_SectionsCountAggregateOutputType {
  id: Int!
  created_at: Int!
  updated_at: Int!
  sort_order: Int!
  name: Int!
  summary: Int!
  audio_url: Int!
  script_id: Int!
  _all: Int!
  _join: Query!
}

type db_SectionsAvgAggregateOutputType {
  sort_order: Float
  _join: Query!
}

type db_SectionsSumAggregateOutputType {
  sort_order: Int
  _join: Query!
}

type db_SectionsMinAggregateOutputType {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int
  name: String
  summary: String
  audio_url: String
  script_id: String
  _join: Query!
}

type db_SectionsMaxAggregateOutputType {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int
  name: String
  summary: String
  audio_url: String
  script_id: String
  _join: Query!
}

type db_AggregateSections {
  _count: db_SectionsCountAggregateOutputType
  _avg: db_SectionsAvgAggregateOutputType
  _sum: db_SectionsSumAggregateOutputType
  _min: db_SectionsMinAggregateOutputType
  _max: db_SectionsMaxAggregateOutputType
  _join: Query!
}

input db_sectionsCountOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
  script_id: db_SortOrder
}

input db_sectionsAvgOrderByAggregateInput {
  sort_order: db_SortOrder
}

input db_sectionsMaxOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
  script_id: db_SortOrder
}

input db_sectionsMinOrderByAggregateInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
  script_id: db_SortOrder
}

input db_sectionsSumOrderByAggregateInput {
  sort_order: db_SortOrder
}

input db_sectionsOrderByWithAggregationInput {
  id: db_SortOrder
  created_at: db_SortOrder
  updated_at: db_SortOrder
  sort_order: db_SortOrder
  name: db_SortOrder
  summary: db_SortOrder
  audio_url: db_SortOrder
  script_id: db_SortOrder
  _count: db_sectionsCountOrderByAggregateInput
  _avg: db_sectionsAvgOrderByAggregateInput
  _max: db_sectionsMaxOrderByAggregateInput
  _min: db_sectionsMinOrderByAggregateInput
  _sum: db_sectionsSumOrderByAggregateInput
}

input db_sectionsScalarWhereWithAggregatesInput {
  AND: db_sectionsScalarWhereWithAggregatesInput
  OR: [db_sectionsScalarWhereWithAggregatesInput]
  NOT: db_sectionsScalarWhereWithAggregatesInput
  id: db_StringWithAggregatesFilter
  created_at: db_DateTimeWithAggregatesFilter
  updated_at: db_DateTimeNullableWithAggregatesFilter
  sort_order: db_IntWithAggregatesFilter
  name: db_StringWithAggregatesFilter
  summary: db_StringWithAggregatesFilter
  audio_url: db_StringNullableWithAggregatesFilter
  script_id: db_StringWithAggregatesFilter
}

type db_SectionsGroupByOutputType {
  id: String!
  created_at: DateTime!
  updated_at: DateTime
  sort_order: Int!
  name: String!
  summary: String!
  audio_url: String
  script_id: String!
  _count: db_SectionsCountAggregateOutputType
  _avg: db_SectionsAvgAggregateOutputType
  _sum: db_SectionsSumAggregateOutputType
  _min: db_SectionsMinAggregateOutputType
  _max: db_SectionsMaxAggregateOutputType
  _join: Query!
}

type Query {
  db_findFirstfragments(where: db_fragmentsWhereInput, orderBy: [db_fragmentsOrderByWithRelationInput], cursor: db_fragmentsWhereUniqueInput, take: Int, skip: Int, distinct: [db_FragmentsScalarFieldEnum]): db_fragments
  db_findManyfragments(where: db_fragmentsWhereInput, orderBy: [db_fragmentsOrderByWithRelationInput], cursor: db_fragmentsWhereUniqueInput, take: Int, skip: Int, distinct: [db_FragmentsScalarFieldEnum]): [db_fragments]!
  db_aggregatefragments(where: db_fragmentsWhereInput, orderBy: [db_fragmentsOrderByWithRelationInput], cursor: db_fragmentsWhereUniqueInput, take: Int, skip: Int): db_AggregateFragments!
  db_groupByfragments(where: db_fragmentsWhereInput, orderBy: [db_fragmentsOrderByWithAggregationInput], by: [db_FragmentsScalarFieldEnum]!, having: db_fragmentsScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_FragmentsGroupByOutputType]!
  db_findUniquefragments(where: db_fragmentsWhereUniqueInput!): db_fragments
  db_findFirstscripts(where: db_scriptsWhereInput, orderBy: [db_scriptsOrderByWithRelationInput], cursor: db_scriptsWhereUniqueInput, take: Int, skip: Int, distinct: [db_ScriptsScalarFieldEnum]): db_scripts
  db_findManyscripts(where: db_scriptsWhereInput, orderBy: [db_scriptsOrderByWithRelationInput], cursor: db_scriptsWhereUniqueInput, take: Int, skip: Int, distinct: [db_ScriptsScalarFieldEnum]): [db_scripts]!
  db_aggregatescripts(where: db_scriptsWhereInput, orderBy: [db_scriptsOrderByWithRelationInput], cursor: db_scriptsWhereUniqueInput, take: Int, skip: Int): db_AggregateScripts!
  db_groupByscripts(where: db_scriptsWhereInput, orderBy: [db_scriptsOrderByWithAggregationInput], by: [db_ScriptsScalarFieldEnum]!, having: db_scriptsScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_ScriptsGroupByOutputType]!
  db_findUniquescripts(where: db_scriptsWhereUniqueInput!): db_scripts
  db_findFirstsections(where: db_sectionsWhereInput, orderBy: [db_sectionsOrderByWithRelationInput], cursor: db_sectionsWhereUniqueInput, take: Int, skip: Int, distinct: [db_SectionsScalarFieldEnum]): db_sections
  db_findManysections(where: db_sectionsWhereInput, orderBy: [db_sectionsOrderByWithRelationInput], cursor: db_sectionsWhereUniqueInput, take: Int, skip: Int, distinct: [db_SectionsScalarFieldEnum]): [db_sections]!
  db_aggregatesections(where: db_sectionsWhereInput, orderBy: [db_sectionsOrderByWithRelationInput], cursor: db_sectionsWhereUniqueInput, take: Int, skip: Int): db_AggregateSections!
  db_groupBysections(where: db_sectionsWhereInput, orderBy: [db_sectionsOrderByWithAggregationInput], by: [db_SectionsScalarFieldEnum]!, having: db_sectionsScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_SectionsGroupByOutputType]!
  db_findUniquesections(where: db_sectionsWhereUniqueInput!): db_sections
  db_queryRaw(query: String!, parameters: [String]): [_Row!]!
  db_queryRawJSON(query: String!, parameters: [String]): JSON
  gql_hello: String
}

input db_scriptsCreateWithoutSectionsInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  name: String!
  summary: String!
  audio_url: String
}

input db_scriptsCreateOrConnectWithoutSectionsInput {
  where: db_scriptsWhereUniqueInput!
  create: db_scriptsCreateWithoutSectionsInput!
}

input db_scriptsCreateNestedOneWithoutSectionsInput {
  create: db_scriptsCreateWithoutSectionsInput
  connectOrCreate: db_scriptsCreateOrConnectWithoutSectionsInput
  connect: db_scriptsWhereUniqueInput
}

input db_sectionsCreateWithoutFragmentsInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  name: String!
  summary: String!
  audio_url: String
  scripts: db_scriptsCreateNestedOneWithoutSectionsInput!
}

input db_sectionsCreateOrConnectWithoutFragmentsInput {
  where: db_sectionsWhereUniqueInput!
  create: db_sectionsCreateWithoutFragmentsInput!
}

input db_sectionsCreateNestedOneWithoutFragmentsInput {
  create: db_sectionsCreateWithoutFragmentsInput
  connectOrCreate: db_sectionsCreateOrConnectWithoutFragmentsInput
  connect: db_sectionsWhereUniqueInput
}

input db_fragmentsCreateInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  content: String!
  audio_url: String!
  sections: db_sectionsCreateNestedOneWithoutFragmentsInput!
}

input db_StringFieldUpdateOperationsInput {
  set: String
}

input db_DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input db_NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input db_IntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input db_NullableStringFieldUpdateOperationsInput {
  set: String
}

input db_scriptsUpdateWithoutSectionsInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  summary: db_StringFieldUpdateOperationsInput
  audio_url: db_NullableStringFieldUpdateOperationsInput
}

input db_scriptsUpsertWithoutSectionsInput {
  update: db_scriptsUpdateWithoutSectionsInput!
  create: db_scriptsCreateWithoutSectionsInput!
}

input db_scriptsUpdateOneRequiredWithoutSectionsInput {
  create: db_scriptsCreateWithoutSectionsInput
  connectOrCreate: db_scriptsCreateOrConnectWithoutSectionsInput
  upsert: db_scriptsUpsertWithoutSectionsInput
  connect: db_scriptsWhereUniqueInput
  update: db_scriptsUpdateWithoutSectionsInput
}

input db_sectionsUpdateWithoutFragmentsInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  sort_order: db_IntFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  summary: db_StringFieldUpdateOperationsInput
  audio_url: db_NullableStringFieldUpdateOperationsInput
  scripts: db_scriptsUpdateOneRequiredWithoutSectionsInput
}

input db_sectionsUpsertWithoutFragmentsInput {
  update: db_sectionsUpdateWithoutFragmentsInput!
  create: db_sectionsCreateWithoutFragmentsInput!
}

input db_sectionsUpdateOneRequiredWithoutFragmentsInput {
  create: db_sectionsCreateWithoutFragmentsInput
  connectOrCreate: db_sectionsCreateOrConnectWithoutFragmentsInput
  upsert: db_sectionsUpsertWithoutFragmentsInput
  connect: db_sectionsWhereUniqueInput
  update: db_sectionsUpdateWithoutFragmentsInput
}

input db_fragmentsUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  sort_order: db_IntFieldUpdateOperationsInput
  content: db_StringFieldUpdateOperationsInput
  audio_url: db_StringFieldUpdateOperationsInput
  sections: db_sectionsUpdateOneRequiredWithoutFragmentsInput
}

input db_fragmentsCreateManyInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  content: String!
  audio_url: String!
  section_id: String!
}

type db_AffectedRowsOutput {
  count: Int!
  _join: Query!
}

input db_fragmentsUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  sort_order: db_IntFieldUpdateOperationsInput
  content: db_StringFieldUpdateOperationsInput
  audio_url: db_StringFieldUpdateOperationsInput
}

input db_fragmentsCreateWithoutSectionsInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  content: String!
  audio_url: String!
}

input db_fragmentsCreateOrConnectWithoutSectionsInput {
  where: db_fragmentsWhereUniqueInput!
  create: [db_fragmentsCreateWithoutSectionsInput!]
}

input db_fragmentsCreateManySectionsInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  content: String!
  audio_url: String!
}

input db_fragmentsCreateManySectionsInputEnvelope {
  data: [db_fragmentsCreateManySectionsInput]!
  skipDuplicates: Boolean
}

input db_fragmentsCreateNestedManyWithoutSectionsInput {
  create: [db_fragmentsCreateWithoutSectionsInput]
  connectOrCreate: [db_fragmentsCreateOrConnectWithoutSectionsInput]
  createMany: [db_fragmentsCreateManySectionsInputEnvelope]
  connect: [db_fragmentsWhereUniqueInput]
}

input db_sectionsCreateWithoutScriptsInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  name: String!
  summary: String!
  audio_url: String
  fragments: db_fragmentsCreateNestedManyWithoutSectionsInput
}

input db_sectionsCreateOrConnectWithoutScriptsInput {
  where: db_sectionsWhereUniqueInput!
  create: [db_sectionsCreateWithoutScriptsInput!]
}

input db_sectionsCreateManyScriptsInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  name: String!
  summary: String!
  audio_url: String
}

input db_sectionsCreateManyScriptsInputEnvelope {
  data: [db_sectionsCreateManyScriptsInput]!
  skipDuplicates: Boolean
}

input db_sectionsCreateNestedManyWithoutScriptsInput {
  create: [db_sectionsCreateWithoutScriptsInput]
  connectOrCreate: [db_sectionsCreateOrConnectWithoutScriptsInput]
  createMany: [db_sectionsCreateManyScriptsInputEnvelope]
  connect: [db_sectionsWhereUniqueInput]
}

input db_scriptsCreateInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  name: String!
  summary: String!
  audio_url: String
  sections: db_sectionsCreateNestedManyWithoutScriptsInput
}

input db_fragmentsUpdateWithoutSectionsInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  sort_order: db_IntFieldUpdateOperationsInput
  content: db_StringFieldUpdateOperationsInput
  audio_url: db_StringFieldUpdateOperationsInput
}

input db_fragmentsUpsertWithWhereUniqueWithoutSectionsInput {
  where: db_fragmentsWhereUniqueInput!
  update: [db_fragmentsUpdateWithoutSectionsInput!]
  create: [db_fragmentsCreateWithoutSectionsInput!]
}

input db_fragmentsUpdateWithWhereUniqueWithoutSectionsInput {
  where: db_fragmentsWhereUniqueInput!
  data: db_fragmentsUpdateWithoutSectionsInput!
}

input db_fragmentsScalarWhereInput {
  AND: db_fragmentsScalarWhereInput
  OR: [db_fragmentsScalarWhereInput]
  NOT: db_fragmentsScalarWhereInput
  id: db_StringFilter
  created_at: db_DateTimeFilter
  updated_at: db_DateTimeNullableFilter
  sort_order: db_IntFilter
  content: db_StringFilter
  audio_url: db_StringFilter
  section_id: db_StringFilter
}

input db_fragmentsUpdateManyWithWhereWithoutSectionsInput {
  where: db_fragmentsScalarWhereInput!
  data: db_fragmentsUpdateManyMutationInput!
}

input db_fragmentsUpdateManyWithoutSectionsInput {
  create: [db_fragmentsCreateWithoutSectionsInput]
  connectOrCreate: [db_fragmentsCreateOrConnectWithoutSectionsInput]
  upsert: [db_fragmentsUpsertWithWhereUniqueWithoutSectionsInput]
  createMany: [db_fragmentsCreateManySectionsInputEnvelope]
  set: db_fragmentsWhereUniqueInput
  disconnect: [db_fragmentsWhereUniqueInput]
  delete: [db_fragmentsWhereUniqueInput]
  connect: [db_fragmentsWhereUniqueInput]
  update: [db_fragmentsUpdateWithWhereUniqueWithoutSectionsInput]
  updateMany: [db_fragmentsUpdateManyWithWhereWithoutSectionsInput]
  deleteMany: db_fragmentsScalarWhereInput
}

input db_sectionsUpdateWithoutScriptsInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  sort_order: db_IntFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  summary: db_StringFieldUpdateOperationsInput
  audio_url: db_NullableStringFieldUpdateOperationsInput
  fragments: db_fragmentsUpdateManyWithoutSectionsInput
}

input db_sectionsUpsertWithWhereUniqueWithoutScriptsInput {
  where: db_sectionsWhereUniqueInput!
  update: [db_sectionsUpdateWithoutScriptsInput!]
  create: [db_sectionsCreateWithoutScriptsInput!]
}

input db_sectionsUpdateWithWhereUniqueWithoutScriptsInput {
  where: db_sectionsWhereUniqueInput!
  data: db_sectionsUpdateWithoutScriptsInput!
}

input db_sectionsScalarWhereInput {
  AND: db_sectionsScalarWhereInput
  OR: [db_sectionsScalarWhereInput]
  NOT: db_sectionsScalarWhereInput
  id: db_StringFilter
  created_at: db_DateTimeFilter
  updated_at: db_DateTimeNullableFilter
  sort_order: db_IntFilter
  name: db_StringFilter
  summary: db_StringFilter
  audio_url: db_StringNullableFilter
  script_id: db_StringFilter
}

input db_sectionsUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  sort_order: db_IntFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  summary: db_StringFieldUpdateOperationsInput
  audio_url: db_NullableStringFieldUpdateOperationsInput
}

input db_sectionsUpdateManyWithWhereWithoutScriptsInput {
  where: db_sectionsScalarWhereInput!
  data: db_sectionsUpdateManyMutationInput!
}

input db_sectionsUpdateManyWithoutScriptsInput {
  create: [db_sectionsCreateWithoutScriptsInput]
  connectOrCreate: [db_sectionsCreateOrConnectWithoutScriptsInput]
  upsert: [db_sectionsUpsertWithWhereUniqueWithoutScriptsInput]
  createMany: [db_sectionsCreateManyScriptsInputEnvelope]
  set: db_sectionsWhereUniqueInput
  disconnect: [db_sectionsWhereUniqueInput]
  delete: [db_sectionsWhereUniqueInput]
  connect: [db_sectionsWhereUniqueInput]
  update: [db_sectionsUpdateWithWhereUniqueWithoutScriptsInput]
  updateMany: [db_sectionsUpdateManyWithWhereWithoutScriptsInput]
  deleteMany: db_sectionsScalarWhereInput
}

input db_scriptsUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  summary: db_StringFieldUpdateOperationsInput
  audio_url: db_NullableStringFieldUpdateOperationsInput
  sections: db_sectionsUpdateManyWithoutScriptsInput
}

input db_scriptsCreateManyInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  name: String!
  summary: String!
  audio_url: String
}

input db_scriptsUpdateManyMutationInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  summary: db_StringFieldUpdateOperationsInput
  audio_url: db_NullableStringFieldUpdateOperationsInput
}

input db_sectionsCreateInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  name: String!
  summary: String!
  audio_url: String
  scripts: db_scriptsCreateNestedOneWithoutSectionsInput!
  fragments: db_fragmentsCreateNestedManyWithoutSectionsInput
}

input db_sectionsUpdateInput {
  id: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  updated_at: db_NullableDateTimeFieldUpdateOperationsInput
  sort_order: db_IntFieldUpdateOperationsInput
  name: db_StringFieldUpdateOperationsInput
  summary: db_StringFieldUpdateOperationsInput
  audio_url: db_NullableStringFieldUpdateOperationsInput
  scripts: db_scriptsUpdateOneRequiredWithoutSectionsInput
  fragments: db_fragmentsUpdateManyWithoutSectionsInput
}

input db_sectionsCreateManyInput {
  id: String
  created_at: DateTime
  updated_at: DateTime
  sort_order: Int!
  name: String!
  summary: String!
  audio_url: String
  script_id: String!
}

type Mutation {
  db_createOnefragments(data: db_fragmentsCreateInput!): db_fragments
  db_upsertOnefragments(where: db_fragmentsWhereUniqueInput!, create: db_fragmentsCreateInput!, update: db_fragmentsUpdateInput!): db_fragments
  db_createManyfragments(data: [db_fragmentsCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOnefragments(where: db_fragmentsWhereUniqueInput!): db_fragments
  db_updateOnefragments(data: db_fragmentsUpdateInput!, where: db_fragmentsWhereUniqueInput!): db_fragments
  db_updateManyfragments(data: db_fragmentsUpdateManyMutationInput!, where: db_fragmentsWhereInput): db_AffectedRowsOutput
  db_deleteManyfragments(where: db_fragmentsWhereInput): db_AffectedRowsOutput
  db_createOnescripts(data: db_scriptsCreateInput!): db_scripts
  db_upsertOnescripts(where: db_scriptsWhereUniqueInput!, create: db_scriptsCreateInput!, update: db_scriptsUpdateInput!): db_scripts
  db_createManyscripts(data: [db_scriptsCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOnescripts(where: db_scriptsWhereUniqueInput!): db_scripts
  db_updateOnescripts(data: db_scriptsUpdateInput!, where: db_scriptsWhereUniqueInput!): db_scripts
  db_updateManyscripts(data: db_scriptsUpdateManyMutationInput!, where: db_scriptsWhereInput): db_AffectedRowsOutput
  db_deleteManyscripts(where: db_scriptsWhereInput): db_AffectedRowsOutput
  db_createOnesections(data: db_sectionsCreateInput!): db_sections
  db_upsertOnesections(where: db_sectionsWhereUniqueInput!, create: db_sectionsCreateInput!, update: db_sectionsUpdateInput!): db_sections
  db_createManysections(data: [db_sectionsCreateManyInput]!, skipDuplicates: Boolean): db_AffectedRowsOutput
  db_deleteOnesections(where: db_sectionsWhereUniqueInput!): db_sections
  db_updateOnesections(data: db_sectionsUpdateInput!, where: db_sectionsWhereUniqueInput!): db_sections
  db_updateManysections(data: db_sectionsUpdateManyMutationInput!, where: db_sectionsWhereInput): db_AffectedRowsOutput
  db_deleteManysections(where: db_sectionsWhereInput): db_AffectedRowsOutput
  db_executeRaw(query: String!, parameters: [String]): Int!
}

scalar DateTime

scalar JSON

scalar UUID

scalar BigInt

scalar db_Bytes

type _Row {
  ID: ID!
  Int: Int!
  Float: Float!
  String: String!
  Boolean: Boolean!
  DateTime: DateTime!
  JSON: JSON!
  Object: _Row!
  Array: [_Row!]!
  OptionalID: ID
  OptionalInt: Int
  OptionalFloat: Float
  OptionalString: String
  OptionalBoolean: Boolean
  OptionalDateTime: DateTime
  OptionalJSON: JSON
  OptionalObject: _Row
  OptionalArray: [_Row!]
  _join: Query!
}

enum COMMON_REGEX_PATTERN {
  EMAIL
  DOMAIN
}

enum WG_ROLE {
  admin
  user
}

"""Well known claims - https://www.iana.org/assignments/jwt/jwt.xhtml"""
enum WG_CLAIM {
  """iss"""
  ISSUER
  """deprecated alias for ISSUER"""
  PROVIDER
  """sub"""
  SUBJECT
  """alias for sub"""
  USERID
  """name"""
  NAME
  """given_name"""
  GIVEN_NAME
  """family_name"""
  FAMILY_NAME
  """middle_name"""
  MIDDLE_NAME
  """nickname"""
  NICKNAME
  """preferred_username"""
  PREFERRED_USERNAME
  """profile"""
  PROFILE
  """picture"""
  PICTURE
  """website"""
  WEBSITE
  """email"""
  EMAIL
  """email_verified"""
  EMAIL_VERIFIED
  """gender"""
  GENDER
  """birthdate"""
  BIRTH_DATE
  """zoneinfo"""
  ZONE_INFO
  """locale"""
  LOCALE
  """location"""
  LOCATION
}

enum WunderGraphDateTimeFormat {
  """2006-01-02T15:04:05-0700"""
  ISO8601
  """Mon Jan _2 15:04:05 2006"""
  ANSIC
  """Mon Jan _2 15:04:05 MST 2006"""
  UnixDate
  """Mon Jan 02 15:04:05 -0700 2006"""
  RubyDate
  """02 Jan 06 15:04 MST"""
  RFC822
  """02 Jan 06 15:04 -0700"""
  RFC822Z
  """Monday, 02-Jan-06 15:04:05 MST"""
  RFC850
  """Mon, 02 Jan 2006 15:04:05 MST"""
  RFC1123
  """Mon, 02 Jan 2006 15:04:05 -0700"""
  RFC1123Z
  """2006-01-02T15:04:05Z07:00"""
  RFC3339
  """2006-01-02T15:04:05.999999999Z07:00"""
  RFC3339Nano
  """3:04PM"""
  Kitchen
  """Jan _2 15:04:05"""
  Stamp
  """Jan _2 15:04:05.000"""
  StampMilli
  """Jan _2 15:04:05.000000"""
  StampMicro
  """Jan _2 15:04:05.000000000"""
  StampNano
}